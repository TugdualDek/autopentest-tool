from plugins.base_plugin import BasePlugin
import aiohttp
import asyncio
import re
import time


class AuthPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.login_urls = []
        self.form_fields = {}
        self.error_message = None
        self.rate_limit_delay = 1  # Délai en secondes entre les tentatives
        self.all_vulnerabilities = []

    def evaluate_success_criteria(self, criterion, action_result):
        if criterion == "vulnerability_found":
            return action_result and len(action_result) > 0
        return super().evaluate_success_criteria(criterion, action_result)

    async def test_authentication(self, login_urls, max_attempts=10):
        if isinstance(login_urls, str):
            login_urls = [login_urls]
        self.login_urls = login_urls
        #print(f"Testing authentication on {len(self.login_urls)} URLs")

        for url in self.login_urls:
            #print(f"Testing URL: {url}")
            vulnerabilities = []
            self.form_fields = {}
            self.error_message = None

            async with aiohttp.ClientSession() as session:
                # Trouver dynamiquement les champs de connexion
                await self.find_login_fields(session, url)

                if not self.form_fields:
                    #print(f"Impossible de trouver les champs de connexion pour {url}")
                    continue

                # Test 1: Tentatives de connexion répétées
                if await self.test_brute_force(session, url, max_attempts):
                    vulnerabilities.append(f"Absence de protection contre les attaques par force brute sur {url}")

                # Test 2: Vérification de la présence de 2FA
                if not await self.test_2fa_presence(session, url):
                    vulnerabilities.append(f"Absence d'authentification à deux facteurs (2FA) sur {url}")

                # Test 3: Test de mots de passe faibles
                if await self.test_weak_passwords(session, url):
                    vulnerabilities.append(f"Acceptation de mots de passe faibles sur {url}")

            self.all_vulnerabilities.extend(vulnerabilities)

        return self.all_vulnerabilities

    async def find_login_fields(self, session, url):
        # Détection de la page de connexion par l'URL
        login_url_keywords = ['login', 'connexion', 'connection', 'signin', 'auth']
        signup_keywords = ['signup', 'register', 'inscription']

        is_login_page = any(keyword in url.lower() for keyword in login_url_keywords)
        is_signup_page = any(keyword in url.lower() for keyword in signup_keywords)

        if is_signup_page and not is_login_page:
            return  # Ignorer les pages d'inscription

        async with session.get(url) as response:
            html = await response.text()

            # Recherche des formulaires
            form_pattern = r'<form.*?>(.*?)</form>'
            forms = re.findall(form_pattern, html, re.DOTALL | re.IGNORECASE)

            # Si aucun formulaire n'est trouvé, on cherche dans toute la page
            search_area = forms[0] if forms else html

            # Recherche des champs d'entrée
            input_pattern = r'<input.*?type=["\'](\w+)["\'].*?name=["\'](\w+)["\']'
            inputs = re.findall(input_pattern, search_area, re.IGNORECASE | re.DOTALL)

            username_field = None
            password_field = None

            for input_type, input_name in inputs:
                if input_type.lower() in ['text', 'email'] and not username_field:
                    username_field = input_name
                elif input_type.lower() == 'password':
                    password_field = input_name

            if username_field and password_field:
                self.form_fields['username'] = username_field
                self.form_fields['password'] = password_field
            elif is_login_page:
                # Si l'URL contient un mot-clé de connexion, on considère la page comme potentielle même sans champs détectés
                self.form_fields['potential_login_page'] = True

            # Recherche d'un message d'erreur potentiel
            error_patterns = ['invalid', 'incorrect', 'failed', 'error']
            for pattern in error_patterns:
                error_match = re.search(f'(?i){pattern}.*?</.*?>', html)
                if error_match:
                    self.error_message = error_match.group(0)
                    break

    async def test_brute_force(self, session, url, max_attempts):
        for i in range(max_attempts):
            start_time = time.time()
            data = {
                self.form_fields['username']: f"test_user_{i}",
                self.form_fields['password']: "wrong_password"
            }
            async with session.post(url, data=data) as response:
                text = await response.text()
                if self.error_message and self.error_message not in text:
                    print(f"Possible compte verrouillé après {i + 1} tentatives")
                    return False
            elapsed_time = time.time() - start_time
            if elapsed_time < self.rate_limit_delay:
                await asyncio.sleep(self.rate_limit_delay - elapsed_time)
        print(f"Aucun verrouillage de compte détecté après {max_attempts} tentatives")
        return True

    async def test_2fa_presence(self, session, url):
        async with session.get(url) as response:
            text = await response.text()
            return "2fa" in text.lower() or "two-factor" in text.lower() or "authenticator" in text.lower()

    async def test_weak_passwords(self, session, url):
        weak_passwords = ["password", "123456", "qwerty", "letmein"]
        for password in weak_passwords:
            data = {
                self.form_fields['username']: "test_user",
                self.form_fields['password']: password
            }
            async with session.post(url, data=data) as response:
                text = await response.text()
                if self.error_message and self.error_message not in text:
                    print(f"Le mot de passe faible '{password}' a été accepté")
                    return True
        return False

    def run(self, login_url, max_attempts=10):
        return asyncio.run(self.test_authentication(login_url, max_attempts))
